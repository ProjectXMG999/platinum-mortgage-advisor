"""
Klient do komunikacji z Azure OpenAI
Zrefaktoryzowany - wykorzystuje serwisy modu≈Çowe
"""
from openai import AzureOpenAI, AsyncAzureOpenAI
from typing import List, Dict, Tuple
import asyncio
from src import config
from src.services import PromptLoader, ValidationService, QualityService, OrchestratorService


class AIClient:
    """Klient do komunikacji z Azure OpenAI API"""
    
    def __init__(self):
        """Inicjalizacja klienta Azure OpenAI"""
        self.client = AzureOpenAI(
            api_version=config.AZURE_OPENAI_API_VERSION,
            azure_endpoint=config.AZURE_OPENAI_ENDPOINT,
            api_key=config.AZURE_OPENAI_API_KEY,
        )
        self.async_client = AsyncAzureOpenAI(
            api_version=config.AZURE_OPENAI_API_VERSION,
            azure_endpoint=config.AZURE_OPENAI_ENDPOINT,
            api_key=config.AZURE_OPENAI_API_KEY,
        )
        self.deployment_name = config.AZURE_OPENAI_DEPLOYMENT_NAME
        print(f"‚úì Po≈ÇƒÖczono z Azure OpenAI: {config.AZURE_OPENAI_ENDPOINT}")
        
        # Inicjalizuj serwisy
        self._init_services()
    
    def _init_services(self):
        """Inicjalizuje modu≈Çy serwisowe"""
        # Prompt loader
        self.prompt_loader = PromptLoader(prompts_dir="src/prompts")
        
        # Validation service (ETAP 1)
        self.validation_service = ValidationService(
            ai_client=self,
            prompt_loader=self.prompt_loader
        )
        
        # Quality service (ETAP 2)
        self.quality_service = QualityService(
            ai_client=self,
            prompt_loader=self.prompt_loader
        )
        
        # Orchestrator service (koordynacja)
        self.orchestrator = OrchestratorService(
            validation_service=self.validation_service,
            quality_service=self.quality_service
        )
        
        print("‚úì Zainicjalizowano serwisy: PromptLoader, ValidationService, QualityService, Orchestrator")
    
    def create_chat_completion(
        self,
        messages: List[Dict[str, str]],
        temperature: float = None,
        max_tokens: int = None
    ) -> str:
        """
        Wysy≈Ça zapytanie do modelu AI
        
        Args:
            messages: Lista wiadomo≈õci w formacie OpenAI
            temperature: Temperatura modelu (0-1)
            max_tokens: Maksymalna liczba token√≥w w odpowiedzi
            
        Returns:
            Odpowied≈∫ od modelu
        """
        try:
            # Przygotuj parametry
            completion_params = {
                "model": self.deployment_name,
                "messages": messages,
            }
            
            # Dostosuj parametry do typu modelu
            model_lower = self.deployment_name.lower()
            if "gpt-5" in model_lower or "o4" in model_lower or "o1" in model_lower:
                # Modele reasoning - temperatura 1.0, max_completion_tokens
                completion_params["temperature"] = temperature if temperature is not None else 1.0
                if max_tokens:
                    completion_params["max_completion_tokens"] = max_tokens
            else:
                # Standardowe modele
                completion_params["temperature"] = temperature if temperature is not None else 0.7
                if max_tokens:
                    completion_params["max_tokens"] = max_tokens
            
            response = self.client.chat.completions.create(**completion_params)
            return response.choices[0].message.content
        
        except Exception as e:
            print(f"‚ùå B≈ÇƒÖd wywo≈Çania API: {e}")
            raise
        """
        Tworzy prompt systemowy do walidacji WYMOG√ìW
        
        Returns:
            Prompt systemowy do pierwszego etapu (walidacja)
        """
        return """validation_prompt.py """
    
    def create_ranking_prompt(self, qualified_banks: List[str]) -> str:
        """
        Tworzy prompt systemowy do rankingu JAKO≈öCI
        
        Args:
            qualified_banks: Lista bank√≥w zakwalifikowanych z etapu 1
            
        Returns:
            Prompt systemowy do drugiego etapu (ranking)
        """
        banks_list = ", ".join(qualified_banks)
        
        # Dostosuj komunikat do liczby bank√≥w
        if len(qualified_banks) == 1:
            ranking_instruction = f"Dok≈Çadnie oceniasz JAKO≈öƒÜ jedynego zakwalifikowanego banku (0-100 pkt)."
        elif len(qualified_banks) == 2:
            ranking_instruction = f"Rankujesz 2 banki: ü•á LEPSZY, ü•à GORSZY."
        elif len(qualified_banks) == 3:
            ranking_instruction = f"Rankujesz 3 banki: ü•á NAJLEPSZY, ü•à DRUGI, ü•â TRZECI."
        else:
            ranking_instruction = f"Wybierasz TOP 4: üèÜ NAJLEPSZY, ü•à DRUGI, ü•â TRZECI, ‚ö†Ô∏è CZWARTY."
        
        return f"""quality_promp.py"""
    
    def validate_requirements(
        self,
        user_query: str,
        knowledge_base_context: str
    ) -> Tuple[str, Dict]:
        """
        ETAP 1: Walidacja WYMOG√ìW - pre-screening bank√≥w
        
        Args:
            user_query: Zapytanie u≈ºytkownika (profil klienta)
            knowledge_base_context: Kontekst z bazy wiedzy
            
        Returns:
            Tuple (odpowied≈∫ JSON jako string, parsed dict)
        """
        validation_prompt = self.create_validation_prompt()
        
        messages = [
            {"role": "system", "content": validation_prompt},
            {"role": "system", "content": f"BAZA WIEDZY BANK√ìW:\n\n{knowledge_base_context}"},
            {"role": "user", "content": f"PROFIL KLIENTA:\n\n{user_query}"}
        ]
        
        print("üîç ETAP 1: Walidacja WYMOG√ìW (pre-screening)...")
        response = self.create_chat_completion(
            messages=messages,
            temperature=0.1,  # Niska temperatura dla precyzji
            max_tokens=16000  # Zwiƒôkszono z 4000 - JSON dla 11 bank√≥w jest d≈Çugi
        )
        
        # Parsuj JSON
        try:
            # Usu≈Ñ markdown code blocks je≈õli istniejƒÖ
            response_clean = response.strip()
            if response_clean.startswith("```json"):
                response_clean = response_clean[7:]
            if response_clean.startswith("```"):
                response_clean = response_clean[3:]
            if response_clean.endswith("```"):
                response_clean = response_clean[:-3]
            
            parsed = json.loads(response_clean.strip())
            return response, parsed
        except json.JSONDecodeError as e:
            print(f"‚ö†Ô∏è B≈ÇƒÖd parsowania JSON z etapu 1: {e}")
            return response, {}
    
    async def validate_single_bank_async(
        self,
        bank_name: str,
        bank_data: Dict,
        user_query: str,
        deployment_name: str = None,
        customer_profile = None
    ) -> Dict:
        """
        ASYNC: Walidacja pojedynczego banku (WYMOGI)
        
        Args:
            bank_name: Nazwa banku
            bank_data: Dane banku z knowledge base
            user_query: Profil klienta
            deployment_name: Opcjonalny model do u≈ºycia (domy≈õlnie self.deployment_name)
            customer_profile: Zmapowany profil klienta (CustomerProfile object)
            
        Returns:
            Dict z wynikiem walidacji dla tego banku
        """
        # Prompt dla pojedynczego banku - INTELIGENTNA WALIDACJA
        if customer_profile:
            # Nowy prompt - sprawdzaj tylko dostƒôpne dane
            validation_prompt = f"""single_validation_prompt.py"""
        else:
            # Stary prompt - sprawdzaj wszystko (fallback)
            validation_prompt = f"""Jeste≈õ ekspertem ds. produkt√≥w hipotecznych w Platinum Financial.

üéØ ZADANIE: Sprawd≈∫ czy bank **{bank_name}** SPE≈ÅNIA wszystkie WYMOGI klienta.

üìã Sprawdzasz TYLKO parametry typu WYM√ìG (eliminatory).

**WYMOGI do sprawdzenia:**
- 02_kredytobiorca (7 WYMOG√ìW): wiek, liczba wnioskodawc√≥w, zwiƒÖzek nieformalny, w≈Ça≈õciciele, rozdzielno≈õƒá, cudzoziemiec
- 03_≈∫r√≥d≈Ço dochodu (20 WYMOG√ìW): wszystkie typy um√≥w i dochod√≥w
- 04_cel kredytu (24 WYMOGI): wszystkie typy transakcji
- 05_zabezpieczenie (14 WYMOG√ìW): typy nieruchomo≈õci, lokalizacja, stan
- 06_ocena zdolno≈õci (13 WYMOG√ìW): metody kalkulacji, wsp√≥≈Çczynniki

**FORMAT ODPOWIEDZI (JSON):**
{{
  "bank_name": "{bank_name}",
  "status": "QUALIFIED" lub "DISQUALIFIED",
  "spelnione_wymogi": ["wym√≥g1", "wym√≥g2", ...],
  "niespelnione_wymogi": ["wym√≥g1: pow√≥d", "wym√≥g2: pow√≥d", ...],
  "kluczowe_problemy": ["problem1", "problem2"] (je≈õli DISQUALIFIED),
  "notatki": "dodatkowe uwagi"
}}

‚ö†Ô∏è Je≈õli choƒá JEDEN WYM√ìG nie jest spe≈Çniony ‚Üí status = "DISQUALIFIED"
‚úÖ Je≈õli WSZYSTKIE WYMOGI sƒÖ spe≈Çnione ‚Üí status = "QUALIFIED"
"""

        bank_context = json.dumps(bank_data, ensure_ascii=False, indent=2)
        
        # Przygotuj messages z uwzglƒôdnieniem customer_profile
        messages = [
            {"role": "system", "content": validation_prompt},
            {"role": "system", "content": f"DANE BANKU {bank_name}:\n\n{bank_context}"}
        ]
        
        # Je≈õli mamy zmapowany profil, u≈ºyj go zamiast surowego user_query
        if customer_profile:
            profile_json = json.dumps(customer_profile.to_dict(), ensure_ascii=False, indent=2)
            messages.append({
                "role": "user", 
                "content": f"ZMAPOWANY PROFIL KLIENTA (JSON):\n\n{profile_json}\n\n‚ö†Ô∏è PAMIƒòTAJ: Sprawdzaj TYLKO pola kt√≥re nie sƒÖ null!"
            })
        else:
            # Fallback - u≈ºyj surowego inputu
            messages.append({
                "role": "user",
                "content": f"PROFIL KLIENTA:\n\n{user_query}"
            })
        
        # U≈ºyj podanego modelu lub domy≈õlnego
        model = deployment_name or self.deployment_name
        
        # Przygotuj parametry zgodnie z typem modelu
        completion_params = {
            "model": model,
            "messages": messages,
        }
        
        model_lower = model.lower()
        if "gpt-5" in model_lower or "o4" in model_lower or "o1" in model_lower:
            completion_params["temperature"] = 1.0
            completion_params["max_completion_tokens"] = 2000  # Mniejsze dla pojedynczego banku
        else:
            completion_params["temperature"] = 0.1
            completion_params["max_tokens"] = 2000
        
        try:
            response = await self.async_client.chat.completions.create(**completion_params)
            result_text = response.choices[0].message.content
            
            # Agresywne czyszczenie dla JSON
            result_clean = result_text.strip()
            
            # Usu≈Ñ markdown code blocks
            if result_clean.startswith("```json"):
                result_clean = result_clean[7:]
            elif result_clean.startswith("```"):
                result_clean = result_clean[3:]
            
            if result_clean.endswith("```"):
                result_clean = result_clean[:-3]
            
            result_clean = result_clean.strip()
            
            # Pr√≥ba parsowania
            try:
                result_dict = json.loads(result_clean)
                return result_dict
            except json.JSONDecodeError:
                # Je≈õli fail, spr√≥buj znale≈∫ƒá JSON w tek≈õcie
                import re
                json_match = re.search(r'\{[\s\S]*\}', result_clean)
                if json_match:
                    try:
                        result_dict = json.loads(json_match.group(0))
                        return result_dict
                    except:
                        pass
                
                # Last resort - zwr√≥ƒá pustƒÖ odpowied≈∫ z informacjƒÖ o b≈Çƒôdzie
                print(f"‚ö†Ô∏è Nie mo≈ºna sparsowaƒá JSONa dla {bank_name}, zwracam pusty wynik")
                print(f"   Pierwsze 200 znak√≥w: {result_text[:200]}")
                return {
                    "bank_name": bank_name,
                    "status": "ERROR",
                    "error": "JSON parsing failed",
                    "raw_response": result_text[:500]
                }
            
        except Exception as e:
            print(f"‚ö†Ô∏è B≈ÇƒÖd walidacji {bank_name}: {e}")
            return {
                "bank_name": bank_name,
                "status": "ERROR",
                "error": str(e)
            }
    
    async def validate_requirements_async(
        self,
        user_query: str,
        knowledge_base: Dict,
        deployment_name: str = None,
        customer_profile = None
    ) -> Tuple[str, Dict]:
        """
        ASYNC PARALLEL: Walidacja WYMOG√ìW dla wszystkich bank√≥w r√≥wnolegle
        
        Args:
            user_query: Zapytanie u≈ºytkownika (profil klienta)
            knowledge_base: Pe≈Çna baza wiedzy (Dict z listƒÖ products)
            deployment_name: Opcjonalny model do u≈ºycia
            customer_profile: Zmapowany profil klienta (CustomerProfile object)
            
        Returns:
            Tuple (odpowied≈∫ JSON jako string, parsed dict)
        """
        print("üîç ETAP 1: Walidacja WYMOG√ìW (PARALLEL MODE)...")
        
        if customer_profile:
            print(f"üìã U≈ºyto zmapowanego profilu - sprawdzam tylko podane parametry")
        
        # Przygotuj listƒô task√≥w dla ka≈ºdego banku
        tasks = []
        for product in knowledge_base.get("products", []):
            bank_name = product.get("bank_name")
            if bank_name:
                task = self.validate_single_bank_async(
                    bank_name=bank_name,
                    bank_data=product,
                    user_query=user_query,
                    deployment_name=deployment_name,
                    customer_profile=customer_profile
                )
                tasks.append(task)
        
        # Wykonaj wszystkie r√≥wnolegle
        print(f"‚ö° Uruchamiam {len(tasks)} r√≥wnoleg≈Çych request√≥w...")
        results = await asyncio.gather(*tasks)
        
        # Po≈ÇƒÖcz wyniki
        qualified_banks = []
        disqualified_banks = []
        
        for result in results:
            if result.get("status") == "QUALIFIED":
                qualified_banks.append(result)
            elif result.get("status") == "DISQUALIFIED":
                disqualified_banks.append(result)
            # Ignoruj ERROR results
        
        # Stw√≥rz finalny JSON
        final_result = {
            "etap": "1_WALIDACJA_WYMOG√ìW",
            "qualified_banks": qualified_banks,
            "disqualified_banks": disqualified_banks,
            "summary": {
                "total_banks": len(results),
                "qualified": len(qualified_banks),
                "disqualified": len(disqualified_banks)
            }
        }
        
        result_json = json.dumps(final_result, ensure_ascii=False, indent=2)
        print(f"‚úì Zakwalifikowane: {len(qualified_banks)}/{len(results)} bank√≥w")
        
        return result_json, final_result
    
    async def rank_single_bank_async(
        self,
        bank_name: str,
        bank_data: Dict,
        user_query: str,
        deployment_name: str = None,
        customer_profile = None
    ) -> Dict:
        """
        ASYNC: Ocena jako≈õci pojedynczego banku (19 parametr√≥w JAKO≈öCI)
        
        Args:
            bank_name: Nazwa banku
            bank_data: Dane banku z knowledge base
            user_query: Profil klienta
            deployment_name: Opcjonalny model do u≈ºycia
            customer_profile: Zmapowany profil klienta (CustomerProfile object)
            
        Returns:
            Dict z ocenƒÖ jako≈õci banku (0-100 punkt√≥w)
        """
        # Inteligentny prompt - oceniaj tylko te parametry, kt√≥re sƒÖ istotne dla klienta
        if customer_profile:
            ranking_prompt = f"""single_quality_prompt.py"""
        else:
            # Stary prompt - punktuj wszystko (fallback)
            ranking_prompt = f"""multi_quality_prompt.py"""

        bank_context = json.dumps(bank_data, ensure_ascii=False, indent=2)
        
        messages = [
            {"role": "system", "content": ranking_prompt},
            {"role": "system", "content": f"DANE BANKU {bank_name}:\n\n{bank_context}"}
        ]
        
        # Dodaj profil klienta - w zale≈ºno≈õci czy mamy zmapowany profil czy raw text
        if customer_profile:
            # Wysy≈Çamy strukturalny JSON profilu do LLM
            profile_json = json.dumps(customer_profile.to_dict(), ensure_ascii=False, indent=2)
            messages.append({
                "role": "user",
                "content": f"ZMAPOWANY PROFIL KLIENTA (JSON):\n\n{profile_json}\n\n‚ö†Ô∏è PAMIƒòTAJ: Punktuj TYLKO parametry istotne dla tego profilu!"
            })
        else:
            # Fallback - stary spos√≥b (raw text)
            messages.append({
                "role": "user",
                "content": f"PROFIL KLIENTA:\n\n{user_query}"
            })
        
        # U≈ºyj podanego modelu lub domy≈õlnego
        model = deployment_name or self.deployment_name
        
        # Przygotuj parametry zgodnie z typem modelu
        completion_params = {
            "model": model,
            "messages": messages,
        }
        
        model_lower = model.lower()
        if "gpt-5" in model_lower or "o4" in model_lower or "o1" in model_lower:
            completion_params["temperature"] = 1.0
            completion_params["max_completion_tokens"] = 2500
        else:
            completion_params["temperature"] = 0.2
            completion_params["max_tokens"] = 2500
        
        try:
            response = await self.async_client.chat.completions.create(**completion_params)
            result_text = response.choices[0].message.content
            
            # Agresywne czyszczenie dla JSON
            result_clean = result_text.strip()
            
            # Usu≈Ñ markdown code blocks
            if result_clean.startswith("```json"):
                result_clean = result_clean[7:]
            elif result_clean.startswith("```"):
                result_clean = result_clean[3:]
            
            if result_clean.endswith("```"):
                result_clean = result_clean[:-3]
            
            result_clean = result_clean.strip()
            
            # Pr√≥ba parsowania
            try:
                result_dict = json.loads(result_clean)
                return result_dict
            except json.JSONDecodeError:
                # Je≈õli fail, spr√≥buj znale≈∫ƒá JSON w tek≈õcie
                import re
                json_match = re.search(r'\{[\s\S]*\}', result_clean)
                if json_match:
                    try:
                        result_dict = json.loads(json_match.group(0))
                        return result_dict
                    except:
                        pass
                
                # Last resort - zwr√≥ƒá domy≈õlnƒÖ ocenƒô
                print(f"‚ö†Ô∏è Nie mo≈ºna sparsowaƒá JSONa oceny dla {bank_name}, zwracam wynik 50/100")
                print(f"   Pierwsze 200 znak√≥w: {result_text[:200]}")
                return {
                    "bank_name": bank_name,
                    "total_score": 50,
                    "breakdown": {
                        "koszt_kredytu": 17,
                        "elastycznosc": 12,
                        "wygoda": 10,
                        "korzysci": 7,
                        "parametry_max": 2
                    },
                    "kluczowe_atuty": ["Ocena automatyczna - b≈ÇƒÖd parsowania"],
                    "punkty_uwagi": ["Nie uda≈Ço siƒô sparsowaƒá odpowiedzi AI"],
                    "error": "JSON parsing failed"
                }
            
        except Exception as e:
            print(f"‚ö†Ô∏è B≈ÇƒÖd oceny {bank_name}: {e}")
            return {
                "bank_name": bank_name,
                "total_score": 0,
                "error": str(e)
            }
    
    async def rank_by_quality_async(
        self,
        user_query: str,
        knowledge_base: Dict,
        qualified_banks: List[str],
        deployment_name: str = None,
        customer_profile = None
    ) -> str:
        """
        ASYNC PARALLEL: Ranking JAKO≈öCI dla wszystkich zakwalifikowanych bank√≥w
        
        Args:
            user_query: Zapytanie u≈ºytkownika (profil klienta)
            knowledge_base: Pe≈Çna baza wiedzy (Dict z listƒÖ products)
            qualified_banks: Lista nazw zakwalifikowanych bank√≥w
            deployment_name: Opcjonalny model do u≈ºycia
            customer_profile: Zmapowany profil klienta (CustomerProfile object)
            
        Returns:
            Markdown z rankingiem TOP 4 bank√≥w
        """
        print(f"üèÖ ETAP 2: Ranking JAKO≈öCI (PARALLEL MODE - {len(qualified_banks)} bank√≥w)...")
        
        # Przygotuj listƒô task√≥w dla ka≈ºdego banku
        tasks = []
        for bank_name in qualified_banks:
            # Znajd≈∫ dane banku
            bank_data = None
            for product in knowledge_base.get("products", []):
                if product.get("bank_name") == bank_name:
                    bank_data = product
                    break
            
            if bank_data:
                task = self.rank_single_bank_async(
                    bank_name=bank_name,
                    bank_data=bank_data,
                    user_query=user_query,
                    deployment_name=deployment_name,
                    customer_profile=customer_profile
                )
                tasks.append(task)
        
        # Wykonaj wszystkie r√≥wnolegle
        print(f"‚ö° Uruchamiam {len(tasks)} r√≥wnoleg≈Çych request√≥w oceny jako≈õci...")
        results = await asyncio.gather(*tasks)
        
        # Sortuj po total_score (malejƒÖco)
        valid_results = [r for r in results if "error" not in r]
        valid_results.sort(key=lambda x: x.get("total_score", 0), reverse=True)
        
        print(f"‚úì Oceniono {len(valid_results)} bank√≥w")
        
        # Formatuj TOP 4 do markdown
        markdown = self._format_ranking_markdown(valid_results[:4], user_query)
        
        return markdown
    
    def _format_ranking_markdown(self, top_banks: List[Dict], user_query: str) -> str:
        """
        Formatuje wyniki rankingu do markdown (TOP 4)
        
        Args:
            top_banks: Lista dict z ocenami bank√≥w (max 4)
            user_query: Profil klienta (dla kontekstu)
            
        Returns:
            Markdown z pe≈Çnym rankingiem TOP 4
        """
        medals = ["ü•á", "ü•à", "ü•â", "üéñÔ∏è"]
        positions = ["NAJLEPSZA OPCJA", "DRUGA OPCJA", "TRZECIA OPCJA", "CZWARTA OPCJA"]
        
        lines = []
        lines.append("# üèÜ RANKING JAKO≈öCI OFERT HIPOTECZNYCH")
        lines.append("")
        lines.append(f"*Ocena dla profilu: {user_query[:100]}...*")
        lines.append("")
        lines.append("="*80)
        lines.append("")
        
        for i, bank in enumerate(top_banks):
            medal = medals[i] if i < len(medals) else f"{i+1}."
            position = positions[i] if i < len(positions) else f"OPCJA #{i+1}"
            
            lines.append(f"## {medal} OFERTA #{i+1}: **{bank['bank_name']}** ‚Äì {position}")
            lines.append("")
            lines.append(f"### üìà OCENA JAKO≈öCI: **{bank['total_score']}/100 punkt√≥w**")
            lines.append("")
            
            # Breakdown kategorii
            breakdown = bank.get("breakdown", {})
            lines.append(f"#### üí∞ KOSZT KREDYTU: {breakdown.get('koszt_kredytu', 0)}/35 pkt")
            
            details = bank.get("details", {})
            if details:
                lines.append(f"- **Wcze≈õniejsza sp≈Çata**: {details.get('wczesniejsza_splata', {}).get('value', 'N/D')} ‚Üí **{details.get('wczesniejsza_splata', {}).get('points', 0)}/10 pkt**")
                lines.append(f"- **Ubezpieczenie pomostowe**: {details.get('ubezpieczenie_pomostowe', {}).get('value', 'N/D')} ‚Üí **{details.get('ubezpieczenie_pomostowe', {}).get('points', 0)}/8 pkt**")
                lines.append(f"- **Ubezpieczenie niskiego wk≈Çadu**: {details.get('ubezpieczenie_niskiego_wkladu', {}).get('value', 'N/D')} ‚Üí **{details.get('ubezpieczenie_niskiego_wkladu', {}).get('points', 0)}/7 pkt**")
                lines.append(f"- **Koszt operatu**: {details.get('koszt_operatu', {}).get('value', 'N/D')} ‚Üí **{details.get('koszt_operatu', {}).get('points', 0)}/5 pkt**")
                lines.append(f"- **Kredyt EKO**: {details.get('kredyt_eko', {}).get('value', 'N/D')} ‚Üí **{details.get('kredyt_eko', {}).get('points', 0)}/5 pkt**")
            lines.append("")
            
            lines.append(f"#### üîß ELASTYCZNO≈öƒÜ: {breakdown.get('elastycznosc', 0)}/25 pkt")
            if details:
                lines.append(f"- **Kwota kredytu**: {details.get('kwota_max', {}).get('value', 'N/D')} ‚Üí **{details.get('kwota_max', {}).get('points', 0)}/8 pkt**")
                lines.append(f"- **Okres kredytowania**: {details.get('okres_kredytowania', {}).get('value', 'N/D')} ‚Üí **{details.get('okres_kredytowania', {}).get('points', 0)}/7 pkt**")
                lines.append(f"- **Karencja**: {details.get('karencja', {}).get('value', 'N/D')} ‚Üí **{details.get('karencja', {}).get('points', 0)}/5 pkt**")
                lines.append(f"- **Typ rat**: {details.get('typ_rat', {}).get('value', 'N/D')} ‚Üí **{details.get('typ_rat', {}).get('points', 0)}/5 pkt**")
            lines.append("")
            
            lines.append(f"#### ‚ö° WYGODA PROCESU: {breakdown.get('wygoda', 0)}/20 pkt")
            if details:
                lines.append(f"- **Rodzaj operatu**: {details.get('rodzaj_operatu', {}).get('value', 'N/D')} ‚Üí **{details.get('rodzaj_operatu', {}).get('points', 0)}/10 pkt**")
                lines.append(f"- **Termin decyzji**: {details.get('termin_decyzji', {}).get('value', 'N/D')} ‚Üí **{details.get('termin_decyzji', {}).get('points', 0)}/5 pkt**")
                lines.append(f"- **Waluty**: {details.get('waluty', {}).get('value', 'N/D')} ‚Üí **{details.get('waluty', {}).get('points', 0)}/5 pkt**")
            lines.append("")
            
            lines.append(f"#### üéÅ DODATKOWE KORZY≈öCI: {breakdown.get('korzysci', 0)}/15 pkt")
            if details:
                lines.append(f"- **Oprocentowanie sta≈Çe**: {details.get('oprocentowanie_stale', {}).get('value', 'N/D')} ‚Üí **{details.get('oprocentowanie_stale', {}).get('points', 0)}/8 pkt**")
                lines.append(f"- **Ubezpieczenie nieruchomo≈õci**: {details.get('ubezpieczenie_nieruchomosci', {}).get('value', 'N/D')} ‚Üí **{details.get('ubezpieczenie_nieruchomosci', {}).get('points', 0)}/4 pkt**")
                lines.append(f"- **Ubezpieczenie utraty pracy**: {details.get('ubezpieczenie_utraty_pracy', {}).get('value', 'N/D')} ‚Üí **{details.get('ubezpieczenie_utraty_pracy', {}).get('points', 0)}/3 pkt**")
            lines.append("")
            
            lines.append(f"#### üìä PARAMETRY MAX: {breakdown.get('parametry_max', 0)}/5 pkt")
            if details:
                lines.append(f"- **LTV po≈ºyczka**: {details.get('ltv_pozyczka', {}).get('value', 'N/D')} ‚Üí **{details.get('ltv_pozyczka', {}).get('points', 0)}/3 pkt**")
                lines.append(f"- **Kwota po≈ºyczki**: {details.get('kwota_pozyczki', {}).get('value', 'N/D')} ‚Üí **{details.get('kwota_pozyczki', {}).get('points', 0)}/2 pkt**")
            lines.append("")
            
            # Kluczowe atuty
            atuty = bank.get("kluczowe_atuty", [])
            if atuty:
                lines.append("### ‚ú® KLUCZOWE ATUTY:")
                for j, atut in enumerate(atuty[:3], 1):
                    lines.append(f"{j}. {atut}")
                lines.append("")
            
            # Punkty uwagi
            uwagi = bank.get("punkty_uwagi", [])
            if uwagi:
                lines.append("### ‚ö†Ô∏è PUNKTY UWAGI:")
                for j, uwaga in enumerate(uwagi, 1):
                    lines.append(f"{j}. {uwaga}")
                lines.append("")
            
            # R√≥≈ºnica vs #1
            if i > 0:
                diff = top_banks[0]["total_score"] - bank["total_score"]
                lines.append(f"### üìâ R√ì≈ªNICA vs #{1}:")
                lines.append(f"- **Punkty**: {bank['total_score']} vs {top_banks[0]['total_score']} (#{1}) = **-{diff} pkt**")
                lines.append("")
            
            lines.append("---")
            lines.append("")
        
        # Tabela por√≥wnawcza
        if len(top_banks) > 1:
            lines.append("## üìä TABELA POR√ìWNAWCZA")
            lines.append("")
            lines.append("| Parametr | " + " | ".join([f"{medals[i]} {b['bank_name']}" for i, b in enumerate(top_banks)]) + " |")
            lines.append("|----------|" + "|".join(["----------"] * len(top_banks)) + "|")
            lines.append("| **TOTAL** | " + " | ".join([f"**{b['total_score']}/100**" for b in top_banks]) + " |")
            
            breakdown_keys = [
                ("Koszt kredytu", "koszt_kredytu"),
                ("Elastyczno≈õƒá", "elastycznosc"),
                ("Wygoda", "wygoda"),
                ("Korzy≈õci", "korzysci"),
                ("Parametry MAX", "parametry_max")
            ]
            
            for label, key in breakdown_keys:
                values = [str(b.get("breakdown", {}).get(key, 0)) for b in top_banks]
                lines.append(f"| {label} | " + " | ".join(values) + " |")
            
            lines.append("")
        
        # Rekomendacja ko≈Ñcowa
        if top_banks:
            winner = top_banks[0]
            lines.append("## üéØ REKOMENDACJA KO≈ÉCOWA")
            lines.append("")
            lines.append(f"**Najlepsza opcja**: **{winner['bank_name']}** zdobywa **{winner['total_score']}/100 punkt√≥w**")
            lines.append("")
            
            if len(top_banks) > 1:
                lines.append(f"**Oszczƒôdno≈õƒá vs #{len(top_banks)}**: ~{winner['total_score'] - top_banks[-1]['total_score']} punkt√≥w przewagi")
            
            lines.append("")
        
        return "\n".join(lines)
    
    def rank_by_quality(
        self,
        user_query: str,
        knowledge_base_context: str,
        qualified_banks: List[str],
        deployment_name: str = None
    ) -> str:
        """
        ETAP 2: Ranking JAKO≈öCI - punktacja zakwalifikowanych bank√≥w
        
        Args:
            user_query: Zapytanie u≈ºytkownika (profil klienta)
            knowledge_base_context: Kontekst z bazy wiedzy
            qualified_banks: Lista bank√≥w zakwalifikowanych z etapu 1
            deployment_name: Opcjonalny model do u≈ºycia
            
        Returns:
            Ranking TOP 4 bank√≥w z ocenƒÖ punktowƒÖ
        """
        ranking_prompt = self.create_ranking_prompt(qualified_banks)
        
        messages = [
            {"role": "system", "content": ranking_prompt},
            {"role": "system", "content": f"BAZA WIEDZY BANK√ìW (tylko zakwalifikowane):\n\n{knowledge_base_context}"},
            {"role": "user", "content": f"PROFIL KLIENTA:\n\n{user_query}"}
        ]
        
        print(f"üèÖ ETAP 2: Ranking JAKO≈öCI ({len(qualified_banks)} bank√≥w)...")
        
        # U≈ºyj podanego modelu lub domy≈õlnego
        original_deployment = self.deployment_name
        if deployment_name:
            self.deployment_name = deployment_name
        
        try:
            response = self.create_chat_completion(
                messages=messages,
                temperature=0.2,  # Trochƒô wy≈ºsza dla kreatywno≈õci w opisach
                max_tokens=6000
            )
        finally:
            # Przywr√≥ƒá oryginalny model
            self.deployment_name = original_deployment
        
        return response
    
    def query_two_stage(
        self,
        user_query: str,
        knowledge_base_context: str,
        etap1_model: str = None,
        etap2_model: str = None,
        use_async: bool = True,
        knowledge_base_dict: Dict = None,
        customer_profile = None
    ) -> Dict[str, str]:
        """
        G≈Ç√≥wna metoda - dwuetapowe przetwarzanie zapytania
        
        Args:
            user_query: Zapytanie u≈ºytkownika
            knowledge_base_context: Kontekst z bazy wiedzy (string)
            etap1_model: Model do ETAP 1 (None = domy≈õlny)
            etap2_model: Model do ETAP 2 (None = domy≈õlny)
            use_async: Czy u≈ºywaƒá async parallel processing
            knowledge_base_dict: Pe≈Çna baza wiedzy jako Dict (dla async)
            customer_profile: Zmapowany profil klienta (CustomerProfile object)
            
        Returns:
            Dict z wynikami obu etap√≥w
        """
        print("\n" + "="*80)
        print("üöÄ TRZYETAPOWY SYSTEM DOPASOWANIA KREDYT√ìW")
        if use_async:
            print("‚ö° Tryb: ASYNC PARALLEL")
        if customer_profile:
            print("üìã Profil zmapowany: TAK")
        print("="*80 + "\n")
        
        # ETAP 1: Walidacja WYMOG√ìW
        if use_async and knowledge_base_dict:
            # Async parallel processing
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            try:
                validation_response, validation_data = loop.run_until_complete(
                    self.validate_requirements_async(
                        user_query=user_query,
                        knowledge_base=knowledge_base_dict,
                        deployment_name=etap1_model,
                        customer_profile=customer_profile
                    )
                )
            finally:
                loop.close()
        else:
            # Sequential processing (stara metoda)
            validation_response, validation_data = self.validate_requirements(
                user_query=user_query,
                knowledge_base_context=knowledge_base_context
            )
        
        if not validation_data:
            print("‚ùå B≈ÇƒÖd w etapie 1 - nie mo≈ºna kontynuowaƒá")
            return {
                "stage1_validation": validation_response,
                "stage2_ranking": "B≈ÇƒÖd: Nie mo≈ºna przej≈õƒá do etapu 2 bez poprawnej walidacji",
                "error": True
            }
        
        # WyciƒÖgnij listƒô zakwalifikowanych bank√≥w
        qualified = []
        if "qualified_banks" in validation_data:
            qualified.extend([b["bank_name"] for b in validation_data["qualified_banks"]])
        if "conditionally_qualified_banks" in validation_data:
            qualified.extend([b["bank_name"] for b in validation_data["conditionally_qualified_banks"]])
        
        print(f"\n‚úÖ Zakwalifikowane banki ({len(qualified)}): {', '.join(qualified)}\n")
        
        if len(qualified) == 0:
            print("‚ùå Brak zakwalifikowanych bank√≥w")
            return {
                "stage1_validation": validation_response,
                "stage2_ranking": "Niestety, ≈ºaden bank nie spe≈Çnia wszystkich wymog√≥w dla tego profilu klienta.",
                "error": False,
                "qualified_banks": []
            }
        
        # ETAP 2: Ranking JAKO≈öCI
        if use_async and knowledge_base_dict:
            # Async parallel processing dla ETAP 2
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            try:
                ranking_response = loop.run_until_complete(
                    self.rank_by_quality_async(
                        user_query=user_query,
                        knowledge_base=knowledge_base_dict,
                        qualified_banks=qualified,
                        deployment_name=etap2_model
                    )
                )
            finally:
                loop.close()
        else:
            # Sequential processing (stara metoda)
            ranking_response = self.rank_by_quality(
                user_query=user_query,
                knowledge_base_context=knowledge_base_context,
                qualified_banks=qualified,
                deployment_name=etap2_model
            )
        
        print("\n" + "="*80)
        print("‚úÖ ANALIZA ZAKO≈ÉCZONA")
        print("="*80 + "\n")
        
        return {
            "stage1_validation": validation_response,
            "stage2_ranking": ranking_response,
            "error": False,
            "qualified_banks": qualified
        }

        
        # Wczytaj klasyfikacjƒô parametr√≥w (WYM√ìG vs JAKO≈öƒÜ)
        self._load_parameter_classification()
    
    def create_chat_completion(
        self,
        messages: List[Dict[str, str]],
        temperature: float = None,
        max_tokens: int = None
    ) -> str:
        """
        Wysy≈Ça zapytanie do modelu AI
        
        Args:
            messages: Lista wiadomo≈õci w formacie OpenAI
            temperature: Temperatura modelu (0-1)
            max_tokens: Maksymalna liczba token√≥w w odpowiedzi
            
        Returns:
            Odpowied≈∫ od modelu
        """
        try:
            # GPT-5 u≈ºywa max_completion_tokens zamiast max_tokens
            completion_params = {
                "model": self.deployment_name,
                "messages": messages,
            }
            
            # Modele nowej generacji (GPT-5, O-series) wymagajƒÖ temperature=1
            model_lower = self.deployment_name.lower()
            if "gpt-5" in model_lower or "o4" in model_lower or "o1" in model_lower:
                completion_params["temperature"] = 1.0  # Wymagane dla nowych modeli
            else:
                completion_params["temperature"] = temperature or config.TEMPERATURE
            
            # Dodaj odpowiedni parametr w zale≈ºno≈õci od modelu
            if "gpt-5" in model_lower or "gpt-4.1" in model_lower or "o4" in model_lower or "o1" in model_lower:
                completion_params["max_completion_tokens"] = max_tokens or config.MAX_TOKENS
            else:
                completion_params["max_tokens"] = max_tokens or config.MAX_TOKENS
            
            response = self.client.chat.completions.create(**completion_params)
            
            return response.choices[0].message.content
        
        except Exception as e:
            print(f"‚úó B≈ÇƒÖd podczas komunikacji z AI: {str(e)}")
            raise
    
    def query_with_context(
        self,
        user_query: str,
        knowledge_base_context: str
    ) -> str:
        """
        Wysy≈Ça zapytanie z kontekstem bazy wiedzy
        
        Args:
            user_query: Zapytanie u≈ºytkownika
            knowledge_base_context: Kontekst z bazy wiedzy
            
        Returns:
            Odpowied≈∫ od modelu
        """
        system_prompt = """ranking_prompt.py"""

        messages = [
            {"role": "system", "content": system_prompt},
            {"role": "system", "content": f"BAZA WIEDZY:\n\n{knowledge_base_context}"},
            {"role": "user", "content": user_query}
        ]
        
        return self.create_chat_completion(messages)
