"""
Aplikacja Streamlit - Wyszukiwarka kredyt√≥w hipotecznych Platinum Financial
Integracja z systemem dwupromptowym (AI)
"""
import streamlit as st

# Konfiguracja strony - MUSI BYƒÜ PIERWSZƒÑ KOMENDƒÑ STREAMLIT
st.set_page_config(
    page_title="Wyszukiwarka kredyt√≥w hipotecznych - Platinum Financial", 
    page_icon="platinum.png",
    layout="wide"
)

import json
import sys
import os

# Dodaj src do ≈õcie≈ºki (kompatybilno≈õƒá z lokalnym i Streamlit Cloud)
current_dir = os.path.dirname(os.path.abspath(__file__))
src_path = os.path.join(current_dir, 'src')
if src_path not in sys.path:
    sys.path.insert(0, src_path)

# Import z pe≈ÇnƒÖ ≈õcie≈ºkƒÖ dla pewno≈õci
try:
    from query_engine import QueryEngine
    from input_mapper import InputMapper
    from models.customer_profile import CUSTOMER_PROFILE_TEMPLATE
except ImportError:
    from src.query_engine import QueryEngine
    from src.input_mapper import InputMapper
    from src.models.customer_profile import CUSTOMER_PROFILE_TEMPLATE

# Lista bank√≥w
banks = [
    "Alior Bank",
    "BNP Paribas",
    "CITI Handlowy",
    "ING Bank ≈ölƒÖski",
    "mBank",
    "Millennium",
    "Pekao SA",
    "PKO BP",
    "Santander",
    "BO≈ö BANK",
    "VELO BANK"
]

# Loga bank√≥w
bank_logos = {
    "Alior Bank": "banks/Alior Bank-azwdue.png",
    "BNP Paribas": "banks/BNP_Paribas-pp9vtd.png",
    "CITI Handlowy": "banks/CITI-vcqq6w.png",
    "ING Bank ≈ölƒÖski": "banks/ING-uo91sp.png",
    "mBank": "banks/mBank-8y80zh.png",
    "Millennium": "banks/millennium-2oevpq.png",
    "Pekao SA": "banks/Pekao-znylvm.png",
    "PKO BP": "banks/PKO BP-kmc274.png",
    "Santander": "banks/Santander-evlk48.png",
    "BO≈ö BANK": "banks/BO≈ö-voctnt.jpg",
    "VELO BANK": "banks/velo-aiuy6v.png",
}

# Inicjalizacja session state
if 'engine' not in st.session_state:
    with st.spinner('Inicjalizacja systemu AI...'):
        try:
            st.session_state.engine = QueryEngine("data/processed/knowledge_base.json")
            st.session_state.input_mapper = InputMapper(st.session_state.engine.ai_client)
            st.session_state.engine_ready = True
        except Exception as e:
            st.session_state.engine_ready = False
            st.session_state.engine_error = str(e)

if 'validation_result' not in st.session_state:
    st.session_state.validation_result = None
    
if 'ranking_result' not in st.session_state:
    st.session_state.ranking_result = None

if 'qualified_banks' not in st.session_state:
    st.session_state.qualified_banks = []
    
if 'disqualified_banks' not in st.session_state:
    st.session_state.disqualified_banks = []

if 'customer_profile' not in st.session_state:
    st.session_state.customer_profile = None

if 'mapped_profile_json' not in st.session_state:
    st.session_state.mapped_profile_json = None


def parse_validation_json(json_text):
    """Parsuje JSON z etapu 1 (walidacja)"""
    try:
        # Usu≈Ñ markdown code blocks
        json_clean = json_text.strip()
        if json_clean.startswith("```json"):
            json_clean = json_clean[7:]
        if json_clean.startswith("```"):
            json_clean = json_clean[3:]
        if json_clean.endswith("```"):
            json_clean = json_clean[:-3]
        
        json_clean = json_clean.strip()
        
        # Pr√≥ba 1: Standardowe parsowanie
        try:
            return json.loads(json_clean)
        except json.JSONDecodeError as e:
            # Pr√≥ba 2: Znajd≈∫ JSON object w tek≈õcie
            import re
            json_match = re.search(r'\{.*\}', json_clean, re.DOTALL)
            if json_match:
                return json.loads(json_match.group(0))
            raise e
            
    except Exception as e:
        st.error(f"‚ö†Ô∏è B≈ÇƒÖd parsowania JSON z etapu 1: {e}")
        with st.expander("üîç Zobacz surowƒÖ odpowied≈∫ AI"):
            st.code(json_text[:2000], language="json")  # Poka≈º pierwsze 2000 znak√≥w
        return None


def extract_bank_score(ranking_text, bank_name):
    """WyciƒÖga punktacjƒô banku z tekstu rankingu"""
    try:
        import re
        
        # R√≥≈ºne wzorce do znalezienia punktacji
        patterns = [
            # "OFERTA #1: ING Bank - 91/100 punkt√≥w"
            rf"OFERTA.*?{re.escape(bank_name)}.*?(\d+)/100",
            # "ING Bank ≈ölƒÖski - **91/100 punkt√≥w**"
            rf"{re.escape(bank_name)}.*?[:\-].*?(\d+)/100",
            # "**OCENA JAKO≈öCI: **91/100 punkt√≥w**" (po nazwie banku)
            rf"{re.escape(bank_name)}.*?OCENA JAKO≈öCI.*?(\d+)/100",
            # "91/100 punkt√≥w" gdziekolwiek po nazwie banku (w ciƒÖgu 500 znak√≥w)
            rf"(?s){re.escape(bank_name)}.{{0,500}}?(\d+)/100",
        ]
        
        for pattern in patterns:
            match = re.search(pattern, ranking_text, re.IGNORECASE | re.DOTALL)
            if match:
                score = int(match.group(1))
                if 0 <= score <= 100:  # Walidacja zakresu
                    return score
        
        # Je≈õli nie znaleziono, szukaj sekcji banku i pierwszej punktacji w niej
        # Znajd≈∫ sekcjƒô danego banku (np. "## ü•á OFERTA #1: ING Bank")
        bank_section_pattern = rf"##.*?{re.escape(bank_name)}(.*?)(?=##|$)"
        bank_section = re.search(bank_section_pattern, ranking_text, re.DOTALL | re.IGNORECASE)
        
        if bank_section:
            section_text = bank_section.group(1)
            # Znajd≈∫ pierwszƒÖ punktacjƒô w tej sekcji
            score_match = re.search(r'(\d+)/100', section_text)
            if score_match:
                score = int(score_match.group(1))
                if 0 <= score <= 100:
                    return score
    except Exception as e:
        print(f"B≈ÇƒÖd extract_bank_score dla {bank_name}: {e}")
    
    return None


def extract_top_reasons(ranking_text, bank_name):
    """WyciƒÖga g≈Ç√≥wne atuty banku z tekstu rankingu"""
    try:
        import re
        
        # Znajd≈∫ sekcjƒô danego banku
        bank_section_pattern = rf"##.*?{re.escape(bank_name)}(.*?)(?=##|$)"
        bank_section = re.search(bank_section_pattern, ranking_text, re.DOTALL | re.IGNORECASE)
        
        if bank_section:
            section = bank_section.group(1)
            
            # Wzorce do znalezienia atut√≥w
            atuty_patterns = [
                r"### ‚ú® KLUCZOWE ATUTY:(.*?)(?=###|$)",
                r"KLUCZOWE ATUTY:(.*?)(?=###|$)",
                r"G≈Ç√≥wne atuty:(.*?)(?=###|$)",
                r"Zalety:(.*?)(?=###|$)",
            ]
            
            for pattern in atuty_patterns:
                atuty_match = re.search(pattern, section, re.DOTALL | re.IGNORECASE)
                if atuty_match:
                    atuty_text = atuty_match.group(1)
                    
                    # WyciƒÖgnij listƒô punktowanƒÖ (r√≥≈ºne formaty)
                    reasons = []
                    
                    # Format: "1. Tekst"
                    numbered = re.findall(r'(?:^|\n)\s*\d+\.\s*([^\n]+)', atuty_text)
                    if numbered:
                        reasons.extend(numbered)
                    
                    # Format: "- Tekst" lub "* Tekst"
                    if not reasons:
                        bulleted = re.findall(r'(?:^|\n)\s*[-*]\s*([^\n]+)', atuty_text)
                        if bulleted:
                            reasons.extend(bulleted)
                    
                    # Format: "‚úì Tekst"
                    if not reasons:
                        checkmarks = re.findall(r'(?:^|\n)\s*[‚úì‚úî]\s*([^\n]+)', atuty_text)
                        if checkmarks:
                            reasons.extend(checkmarks)
                    
                    if reasons:
                        return [r.strip() for r in reasons[:3]]  # Max 3 atuty
            
            # Fallback: we≈∫ pierwsze 3 linie z punktami z ca≈Çej sekcji
            all_points = re.findall(r'(?:^|\n)\s*[-*‚Ä¢]\s*([^\n]+)', section)
            if all_points:
                return [p.strip() for p in all_points[:3]]
        
    except Exception as e:
        print(f"B≈ÇƒÖd extract_top_reasons dla {bank_name}: {e}")
    
    return ["Zobacz pe≈Çny raport poni≈ºej"]

# Logo i tytu≈Ç
st.logo("platinum.png")
st.markdown("# üè¶ Wyszukiwarka Kredyt√≥w Hipotecznych")
st.markdown("### *System dwupromptowy z AI - precyzyjna analiza 11 bank√≥w*")

# Sprawd≈∫ czy silnik gotowy
if not st.session_state.engine_ready:
    st.error(f"‚ùå B≈ÇƒÖd inicjalizacji systemu: {st.session_state.get('engine_error', 'Nieznany b≈ÇƒÖd')}")
    st.info("Upewnij siƒô, ≈ºe plik `data/processed/knowledge_base.json` istnieje i jest poprawny.")
    st.stop()

# G≈Ç√≥wny layout - 3 kolumny
col1, col2, col3 = st.columns([2, 3, 3])

with col1:
    st.markdown("### üìù Profil Klienta")
    
    # Przycisk pomocy - szablon
    with st.expander("üìñ **PRZEWODNIK: Jakie dane mogƒô podaƒá?**", expanded=False):
        st.markdown("""
        ### ‚ö†Ô∏è **WYMAGANE MINIMUM:**
        1. **Wiek** kredytobiorcy (np. 45 lat)
        2. **Typ dochodu** (np. UoP, dzia≈Çalno≈õƒá, emerytura)
        3. **Sta≈º pracy** (np. 5 lat)
        4. **Cel kredytu** (np. zakup mieszkania)
        5. **Warto≈õƒá nieruchomo≈õci** lub **kwota kredytu**
        
        ### üí° **OPCJONALNE (podaj je≈õli dotyczy):**
        
        **üë§ Dane osobowe:**
        - Wiek wsp√≥≈Çkredytobiorcy
        - Obywatelstwo (cudzoziemiec?)
        - Status zwiƒÖzku (ma≈Ç≈ºe≈Ñstwo, konkubinat)
        
        **üí∞ Dochody:**
        - Wysoko≈õƒá dochodu miesiƒôcznego
        - Dodatkowe ≈∫r√≥d≈Ça dochodu
        - Typ umowy wsp√≥≈Çkredytobiorcy
        
        **üí≥ Parametry kredytu:**
        - Wk≈Çad w≈Çasny (kwota lub %)
        - LTV
        - Okres kredytowania (lata/miesiƒÖce)
        - Waluta (PLN/EUR)
        - Karencja
        - Kredyt EKO
        - Liczba istniejƒÖcych kredyt√≥w
        
        **üè° Nieruchomo≈õƒá:**
        - Typ (mieszkanie/dom/dzia≈Çka)
        - Lokalizacja
        - Powierzchnia
        - Powierzchnia dzia≈Çki
        - Transakcja rodzinna?
        - Zabezpieczenie osoby trzeciej?
        
        ### üìù **Przyk≈Çady typ√≥w dochodu:**
        - Umowa o pracƒô (okre≈õlona/nieokre≈õlona)
        - Dzia≈Çalno≈õƒá gospodarcza (KPiR/pe≈Çna/rycza≈Çt)
        - Emerytura / Renta
        - Kontrakt menad≈ºerski
        - Umowa zlecenie / o dzie≈Ço
        - Dochody z najmu
        
        ### üéØ **Przyk≈Çady cel√≥w:**
        - Zakup mieszkania/domu
        - Budowa domu (gospodarczy/zlecony)
        - Zakup dzia≈Çki (budowlana/rolna/rekreacyjna)
        - Refinansowanie
        - Konsolidacja
        - Cel dowolny (po≈ºyczka hipoteczna)
        """)
    
    # Przyk≈Çadowe profile
    example_profiles = {
        "Wybierz przyk≈Çad...": "",
        "üë®‚Äçüíº Standardowy (45 lat, zakup mieszkania)": """Klient: Jan Kowalski, 45 lat
Wsp√≥≈Çkredytobiorca: Anna Kowalska, 42 lata

DOCHODY:
- Jan: Umowa o pracƒô na czas nieokre≈õlony, sta≈º 5 lat, doch√≥d 8000 z≈Ç/mc
- Anna: Umowa o pracƒô na czas nieokre≈õlony, sta≈º 3 lata, doch√≥d 6000 z≈Ç/mc

CEL: Zakup mieszkania na rynku wt√≥rnym w Warszawie

PARAMETRY:
- Warto≈õƒá mieszkania: 800,000 z≈Ç
- Wk≈Çad w≈Çasny: 160,000 z≈Ç (20%)
- Kwota kredytu: 640,000 z≈Ç
- LTV: 80%
- Okres: 25 lat (300 miesiƒôcy)

NIERUCHOMO≈öƒÜ:
- Typ: mieszkanie
- Lokalizacja: Warszawa
- Powierzchnia: 75 m2

DODATKOWE:
- Status: ma≈Ç≈ºe≈Ñstwo
- Obywatele Polski
- Brak innych kredyt√≥w hipotecznych
- Zainteresowani kredytem EKO""",
        
        "üë¥ Senior (68 lat, dzia≈Çka rekreacyjna)": """Klient: Senior, 68 lat
Wsp√≥≈Çkredytobiorca: Ma≈Ç≈ºonka, 65 lat

DOCHODY:
- Klient: Emerytura, 5000 z≈Ç/mc
- Wsp√≥≈Çkredytobiorca: Emerytura, 4000 z≈Ç/mc

CEL: Zakup dzia≈Çki rekreacyjnej

PARAMETRY:
- Powierzchnia dzia≈Çki: 1500 m2
- Cena dzia≈Çki: 150,000 z≈Ç
- Wk≈Çad w≈Çasny: 50,000 z≈Ç (33%)
- Kwota kredytu: 100,000 z≈Ç
- Okres: 10 lat

NIERUCHOMO≈öƒÜ:
- Typ: dzia≈Çka rekreacyjna
- Lokalizacja: g√≥ry

DODATKOWE:
- Status: ma≈Ç≈ºe≈Ñstwo""",
        
        "üèóÔ∏è Budowa domu (35 lat)": """Klient: Ma≈Çgorzata Nowak, 35 lat
Wsp√≥≈Çkredytobiorca: Piotr Nowak, 37 lat

DOCHODY:
- Ma≈Çgorzata: UoP na czas nieokre≈õlony, 8000 z≈Ç/mc, sta≈º 4 lata
- Piotr: Dzia≈Çalno≈õƒá gospodarcza KPiR, 24 miesiƒÖce

CEL: Budowa domu jednorodzinnego systemem zleconym

PARAMETRY:
- Koszt budowy: 600,000 z≈Ç
- Dzia≈Çka w posiadaniu (warto≈õƒá 100,000 z≈Ç)
- Wk≈Çad w≈Çasny: 140,000 z≈Ç (20%)
- Kwota kredytu: 560,000 z≈Ç
- Okres: 30 lat

NIERUCHOMO≈öƒÜ:
- Typ: dom (budowa)
- Powierzchnia dzia≈Çki: 800 m2
- Pozwolenie na budowƒô: tak

DODATKOWE:
- Status: ma≈Ç≈ºe≈Ñstwo
- Dzia≈Çka jako czƒô≈õƒá wk≈Çadu w≈Çasnego""",
        
        "üè¢ Lokal u≈ºytkowy (40 lat, kontrakt B2B)": """Klient: Przedsiƒôbiorca, 40 lat

DOCHODY:
- Kontrakt menad≈ºerski (B2B), 36 miesiƒôcy, 15000 z≈Ç/mc

CEL: Zakup lokalu u≈ºytkowego pod biuro

PARAMETRY:
- Warto≈õƒá lokalu: 500,000 z≈Ç
- Wk≈Çad w≈Çasny: 150,000 z≈Ç (30%)
- Kwota kredytu: 350,000 z≈Ç
- LTV: 70%
- Okres: 20 lat

NIERUCHOMO≈öƒÜ:
- Typ: lokal u≈ºytkowy
- Lokalizacja: Krak√≥w (miasto >100k)
- Powierzchnia: 50 m2

DODATKOWE:
- Status: single
- Brak innych kredyt√≥w"""
    }
    
    selected_example = st.selectbox(
        "Szybki start - wybierz przyk≈Çad:",
        options=list(example_profiles.keys()),
        index=0
    )
    
    user_description = st.text_area(
        "Opisz profil klienta (mo≈ºesz w dowolnej formie - system AI zrozumie):",
        value=example_profiles[selected_example],
        height=400,
        placeholder="""Podaj dane klienta w dowolnej formie, np.:

Jan Kowalski, 45 lat
UoP na sta≈Çe, sta≈º 5 lat
Zakup mieszkania za 800k
Wk≈Çad w≈Çasny 20%
Okres 25 lat
"""
    )
    
    # Przycisk analizy
    analyze_button = st.button(
        "üîç Znajd≈∫ pasujƒÖce oferty", 
        type="primary",
        use_container_width=True,
        disabled=(not user_description.strip())
    )
    
    if analyze_button and user_description.strip():
        # Pobierz wybrane modele z session state
        mapper_model = st.session_state.get('mapper_model', 'gpt-4.1')
        etap1 = st.session_state.get('etap1_model', 'gpt-4.1')
        etap2 = st.session_state.get('etap2_model', 'gpt-4.1')
        use_async_mode = st.session_state.get('use_async', True)
        
        # ====================================================================
        # KROK 0: MAPOWANIE INPUTU NA MODEL DANYCH
        # ====================================================================
        with st.spinner(f'üîÑ KROK 0: Mapowanie danych klienta [{mapper_model}]...'):
            try:
                profile, profile_dict = st.session_state.input_mapper.map_input_to_profile(
                    user_input=user_description,
                    model_name=mapper_model
                )
                
                st.session_state.customer_profile = profile
                st.session_state.mapped_profile_json = profile_dict
                
                # Sprawd≈∫ czy profil kompletny
                if not profile.is_complete():
                    missing = profile.get_missing_required_fields()
                    st.warning(f"‚ö†Ô∏è BrakujƒÖce wymagane dane: {', '.join(missing)}")
                    st.info("üí° Analiza bƒôdzie przeprowadzona, ale mo≈ºe byƒá niepe≈Çna.")
                else:
                    st.success("‚úÖ Profil klienta zmapowany pomy≈õlnie!")
                
                # Poka≈º zmapowany profil w expander
                with st.expander("üîç Zobacz zmapowany profil (JSON)", expanded=False):
                    st.json(profile.to_dict())
                
            except Exception as e:
                st.error(f"‚ùå B≈ÇƒÖd mapowania profilu: {str(e)}")
                st.stop()
        
        # ====================================================================
        # KROK 1 i 2: ANALIZA DWUETAPOWA (ze zmapowanym profilem)
        # ====================================================================
        spinner_text = f'ü§ñ ETAP 1: Walidacja WYMOG√ìW [{etap1}] {"‚ö° ASYNC" if use_async_mode else ""}...'
        
        with st.spinner(spinner_text):
            try:
                # Przeka≈º zmapowany profil jako context
                profile_context = json.dumps(st.session_state.mapped_profile_json, ensure_ascii=False, indent=2)
                
                # Uruchom system dwupromptowy z wybranymi modelami
                result = st.session_state.engine.ai_client.query_two_stage(
                    user_query=user_description,
                    knowledge_base_context=st.session_state.engine.data_processor.format_compact_for_context(),
                    etap1_model=etap1,
                    etap2_model=etap2,
                    use_async=use_async_mode,
                    knowledge_base_dict=st.session_state.engine.data_processor.knowledge_base,
                    customer_profile=st.session_state.customer_profile  # Przeka≈º zmapowany profil
                )
                
                if not result.get("error"):
                    # Parsuj wynik etapu 1
                    validation_json = parse_validation_json(result["stage1_validation"])
                    
                    if validation_json:
                        st.session_state.validation_result = validation_json
                        st.session_state.ranking_result = result["stage2_ranking"]
                        
                        # DEBUG: Poka≈º fragment rankingu w konsoli
                        print("\n" + "="*80)
                        print("üîç FRAGMENT RANKINGU (pierwsze 500 znak√≥w):")
                        print("="*80)
                        print(result["stage2_ranking"][:500])
                        print("="*80 + "\n")
                        
                        # WyciƒÖgnij listy bank√≥w
                        st.session_state.qualified_banks = []
                        st.session_state.disqualified_banks = []
                        
                        for bank in validation_json.get("qualified_banks", []):
                            bank_name = bank["bank_name"]
                            score = extract_bank_score(result["stage2_ranking"], bank_name)
                            reasons = extract_top_reasons(result["stage2_ranking"], bank_name)
                            
                            # Debug - wy≈õwietl je≈õli nie znaleziono score
                            if score is None:
                                print(f"‚ö†Ô∏è Nie znaleziono punktacji dla: {bank_name}")
                                # Fallback - przypisz 0 zamiast None
                                score = 0
                            
                            # Obs≈Çuga obu format√≥w (stary i nowy async)
                            # Nowy format: spelnione_wymogi, niespelnione_wymogi
                            # Stary format: requirements_met, requirements_total
                            if "spelnione_wymogi" in bank:
                                # Nowy format async
                                requirements_met = len(bank.get("spelnione_wymogi", []))
                                requirements_total = requirements_met + len(bank.get("niespelnione_wymogi", []))
                            else:
                                # Stary format
                                requirements_met = bank.get("requirements_met", 0)
                                requirements_total = bank.get("requirements_total", 0)
                            
                            bank_info = {
                                "name": bank_name,
                                "status": "qualified",
                                "score": score,
                                "reasons": reasons,
                                "requirements_met": requirements_met,
                                "requirements_total": requirements_total
                            }
                            st.session_state.qualified_banks.append(bank_info)
                        
                        for bank in validation_json.get("disqualified_banks", []):
                            # Obs≈Çuga obu format√≥w
                            if "kluczowe_problemy" in bank:
                                # Nowy format async
                                critical_issues = bank.get("kluczowe_problemy", [])
                                requirements_met = len(bank.get("spelnione_wymogi", []))
                                requirements_total = requirements_met + len(bank.get("niespelnione_wymogi", []))
                            else:
                                # Stary format
                                critical_issues = bank.get("critical_issues", [])
                                requirements_met = bank.get("requirements_met", 0)
                                requirements_total = bank.get("requirements_total", 0)
                            
                            bank_info = {
                                "name": bank["bank_name"],
                                "status": "disqualified",
                                "critical_issues": critical_issues,
                                "requirements_met": requirements_met,
                                "requirements_total": requirements_total
                            }
                            st.session_state.disqualified_banks.append(bank_info)
                        
                        # Sortuj qualified banki po score
                        st.session_state.qualified_banks.sort(
                            key=lambda x: x.get("score", 0) or 0, 
                            reverse=True
                        )
                        
                        st.success(f"‚úÖ Analiza zako≈Ñczona! Zakwalifikowane: {len(st.session_state.qualified_banks)}/11")
                    else:
                        st.error("‚ùå B≈ÇƒÖd parsowania wynik√≥w walidacji")
                else:
                    st.error(f"‚ùå B≈ÇƒÖd analizy: {result.get('stage2_ranking', 'Nieznany b≈ÇƒÖd')}")
                    
            except Exception as e:
                st.error(f"‚ùå B≈ÇƒÖd podczas analizy: {str(e)}")
                import traceback
                st.code(traceback.format_exc())


with col2:
    st.markdown(f"### ‚úÖ PasujƒÖce oferty ({len(st.session_state.qualified_banks)}/11)")
    
    if st.session_state.qualified_banks:
        for idx, bank_info in enumerate(st.session_state.qualified_banks):
            bank_name = bank_info["name"]
            
            # Emoji dla TOP 3
            if idx == 0:
                emoji = "üèÜ"
                border_color = "#FFD700"  # Gold
            elif idx == 1:
                emoji = "ü•à"
                border_color = "#C0C0C0"  # Silver
            elif idx == 2:
                emoji = "ü•â"
                border_color = "#CD7F32"  # Bronze
            else:
                emoji = "‚úÖ"
                border_color = "#4CAF50"  # Green
            
            with st.container(border=True):
                cols = st.columns([1, 5, 2])
                
                with cols[0]:
                    # Logo banku
                    logo_path = bank_logos.get(bank_name, "")
                    if logo_path and os.path.exists(logo_path):
                        st.image(logo_path, width=60)
                    else:
                        st.markdown(f"### {emoji}")
                
                with cols[1]:
                    # Nazwa i punktacja
                    if bank_info.get("score"):
                        st.markdown(f"**{emoji} {bank_name}** - **{bank_info['score']}/100 pkt**")
                    else:
                        st.markdown(f"**{emoji} {bank_name}**")
                    
                    # Wymogi spe≈Çnione
                    st.caption(f"Wymogi: {bank_info['requirements_met']}/{bank_info['requirements_total']} ‚úÖ")
                
                with cols[2]:
                    # Przycisk szczeg√≥≈Ç√≥w
                    with st.popover("üìä Szczeg√≥≈Çy", use_container_width=True):
                        st.markdown(f"### {bank_name}")
                        
                        if bank_info.get("score"):
                            st.metric("Punktacja", f"{bank_info['score']}/100")
                        
                        st.markdown("**G≈Ç√≥wne atuty:**")
                        for reason in bank_info.get("reasons", []):
                            st.markdown(f"‚úì {reason}")
                        
                        # Link do pe≈Çnego raportu
                        if st.session_state.ranking_result:
                            with st.expander("üìÑ Pe≈Çny raport"):
                                st.markdown(st.session_state.ranking_result)
    else:
        st.info("üëà Wprowad≈∫ profil klienta i kliknij 'Znajd≈∫ pasujƒÖce oferty'")
        st.markdown("""
        **System dwupromptowy analizuje:**
        - ‚úÖ **ETAP 1**: Walidacja 68 WYMOG√ìW (kwalifikacja)
        - üèÖ **ETAP 2**: Ranking 19 JAKO≈öCI (punktacja 0-100)
        
        **Otrzymasz:**
        - Lista zakwalifikowanych bank√≥w
        - TOP 4 ranking z uzasadnieniem
        - Szczeg√≥≈Çowe powody odrzucenia
        """)

with col3:
    st.markdown(f"### ‚ùå NiepasujƒÖce oferty ({len(st.session_state.disqualified_banks)}/11)")
    
    if st.session_state.disqualified_banks:
        for bank_info in st.session_state.disqualified_banks:
            bank_name = bank_info["name"]
            
            with st.container(border=True):
                cols = st.columns([1, 5])
                
                with cols[0]:
                    # Logo banku (szare)
                    logo_path = bank_logos.get(bank_name, "")
                    if logo_path and os.path.exists(logo_path):
                        st.image(logo_path, width=60)
                    else:
                        st.markdown("### ‚ö†Ô∏è")
                
                with cols[1]:
                    st.markdown(f"**{bank_name}**")
                    
                    # Wymogi niespe≈Çnione
                    unmet = bank_info['requirements_total'] - bank_info['requirements_met']
                    st.caption(f"Niespe≈Çnione wymogi: {unmet}")
                    
                    # G≈Ç√≥wne problemy
                    critical_issues = bank_info.get("critical_issues", [])
                    if critical_issues:
                        st.markdown("**Powody odrzucenia:**")
                        for issue in critical_issues[:2]:  # Max 2 powody
                            st.markdown(f"<span style='color: #f44336; font-size: 0.9em;'>{issue}</span>", 
                                      unsafe_allow_html=True)
                        
                        if len(critical_issues) > 2:
                            with st.expander(f"+ {len(critical_issues) - 2} wiƒôcej"):
                                for issue in critical_issues[2:]:
                                    st.markdown(f"- {issue}")
    else:
        if st.session_state.qualified_banks:
            st.success("üéâ Wszystkie banki zakwalifikowane!")
        else:
            st.info("Tutaj pojawiƒÖ siƒô banki odrzucone po analizie")

# ============================================================================
# RANKING TOP BANK√ìW WED≈ÅUG JAKO≈öCI (ETAP 2)
# ============================================================================
if st.session_state.qualified_banks and st.session_state.ranking_result:
    st.markdown("---")
    
    # Tytu≈Ç dostosowany do liczby bank√≥w
    num_banks = len(st.session_state.qualified_banks)
    if num_banks == 1:
        st.markdown("## üèÜ OCENA JAKO≈öCI OFERTY")
        st.markdown("*Szczeg√≥≈Çowa analiza 19 parametr√≥w jako≈õciowych*")
    else:
        st.markdown("## üèÜ RANKING BANK√ìW WG JAKO≈öCI OFERTY")
        st.markdown(f"*Ocena 19 parametr√≥w jako≈õciowych - TOP {min(num_banks, 4)} z {num_banks} zakwalifikowanych*")
    
    # TOP banki w kartkach (1-4)
    top_banks = st.session_state.qualified_banks[:4]
    
    if len(top_banks) >= 4:
        cols_top = st.columns(4)
    elif len(top_banks) == 3:
        cols_top = st.columns(3)
    elif len(top_banks) == 2:
        cols_top = st.columns(2)
    else:
        cols_top = [st.container()]
    
    medals = ["ü•á", "ü•à", "ü•â", "üéñÔ∏è"]
    colors = ["#FFD700", "#C0C0C0", "#CD7F32", "#4CAF50"]
    place_names = ["NAJLEPSZA OFERTA", "DRUGIE MIEJSCE", "TRZECIE MIEJSCE", "CZWARTE MIEJSCE"]
    
    for idx, bank_info in enumerate(top_banks):
        with cols_top[idx] if len(top_banks) > 1 else cols_top[0]:
            bank_name = bank_info["name"]
            score = bank_info.get("score", 0)
            
            # Dostosuj komunikat dla jedynego banku
            if num_banks == 1:
                place_text = "JEDYNA ZAKWALIFIKOWANA OFERTA"
            else:
                place_text = f"{place_names[idx]}"
            
            # Karta banku z gradientem
            st.markdown(f"""
            <div style="
                background: linear-gradient(135deg, {colors[idx]}20 0%, {colors[idx]}40 100%);
                border: 2px solid {colors[idx]};
                border-radius: 12px;
                padding: 20px;
                text-align: center;
                min-height: 280px;
            ">
                <div style="font-size: 3em; margin-bottom: 10px;">{medals[idx]}</div>
                <div style="font-size: 1.3em; font-weight: bold; margin-bottom: 8px;">
                    {bank_name}
                </div>
                <div style="font-size: 2.5em; font-weight: bold; color: {colors[idx]}; margin: 15px 0;">
                    {score}<span style="font-size: 0.5em; color: #666;">/100</span>
                </div>
                <div style="font-size: 0.85em; color: #666; margin-bottom: 10px;">
                    {place_text}
                </div>
            </div>
            """, unsafe_allow_html=True)
            
            # Logo banku pod kartƒÖ
            logo_path = bank_logos.get(bank_name, "")
            if logo_path and os.path.exists(logo_path):
                st.image(logo_path, width=80)
            
            # G≈Ç√≥wne atuty w expander
            reasons = bank_info.get("reasons", [])
            if reasons:
                with st.expander("‚ú® Kluczowe atuty"):
                    for reason in reasons:
                        st.markdown(f"‚úì {reason}")
    
    # Pe≈Çny raport AI w ekspandowanym bloku
    st.markdown("---")
    with st.expander("üìÑ **PE≈ÅNY RAPORT JAKO≈öCIOWY (ETAP 2: AI Analysis)**", expanded=False):
        st.markdown(st.session_state.ranking_result)
        
        # Przycisk download
        st.download_button(
            label="üíæ Pobierz raport jako Markdown",
            data=st.session_state.ranking_result,
            file_name=f"ranking_kredytowy_{st.session_state.validation_result.get('customer_summary', {}).get('loan_purpose', 'raport')[:30]}.md",
            mime="text/markdown",
            use_container_width=True
        )
    
    # Podsumowanie statystyk
    st.markdown("---")
    stat_cols = st.columns(4)
    
    with stat_cols[0]:
        st.metric(
            "üìä Przeanalizowane banki", 
            f"{len(st.session_state.qualified_banks)}/11",
            delta="Zakwalifikowane"
        )
    
    with stat_cols[1]:
        avg_score = sum(b.get("score", 0) for b in st.session_state.qualified_banks if b.get("score")) / max(len([b for b in st.session_state.qualified_banks if b.get("score")]), 1)
        st.metric(
            "üìà ≈örednia punktacja", 
            f"{avg_score:.1f}/100",
            delta="Jako≈õƒá ofert"
        )
    
    with stat_cols[2]:
        if top_banks:
            st.metric(
                "üèÜ Najlepsza oferta", 
                top_banks[0]["name"],
                delta=f"{top_banks[0].get('score', 0)}/100 pkt"
            )
    
    with stat_cols[3]:
        st.metric(
            "‚úÖ Parametry sprawdzone", 
            "87 total",
            delta="68 WYMOG√ìW + 19 JAKO≈öCI"
        )

# Sidebar - informacje
with st.sidebar:
    st.markdown("### ü§ñ Konfiguracja modeli AI")
    
    # Dostƒôpne modele
    available_models = [
        "gpt-4.1",
        "gpt-4.1-nano", 
        "gpt-5-mini",
        "gpt-5-nano",
        "o1",
        "o4-mini"
    ]
    
    # Wyb√≥r modelu dla MAPPER (nowy!)
    mapper_model = st.selectbox(
        "üîÑ Model MAPPER (Ekstrakcja danych)",
        available_models,
        index=0,  # domy≈õlnie gpt-4.1
        help="Model do mapowania inputu u≈ºytkownika na strukturƒô danych. Rekomendacja: gpt-4.1 dla precyzji"
    )
    
    # Wyb√≥r modelu dla ETAP 1 (Walidacja)
    etap1_model = st.selectbox(
        "üîç Model ETAP 1 (Walidacja WYMOG√ìW)",
        available_models,
        index=0,  # domy≈õlnie gpt-4.1
        help="Model do walidacji parametr√≥w eliminujƒÖcych. Rekomendacja: gpt-4.1 lub o4-mini dla szybko≈õci"
    )
    
    # Wyb√≥r modelu dla ETAP 2 (Ranking)
    etap2_model = st.selectbox(
        "üèÖ Model ETAP 2 (Ranking JAKO≈öCI)",
        available_models,
        index=0,  # domy≈õlnie gpt-4.1
        help="Model do rankingu parametr√≥w jako≈õciowych. Rekomendacja: gpt-4.1 dla najlepszej jako≈õci"
    )
    
    # Async mode toggle
    use_async = st.checkbox(
        "‚ö° Async Parallel Processing",
        value=True,
        help="R√≥wnoleg≈Çe przetwarzanie bank√≥w = 80-90% szybciej (31s ‚Üí 3-5s)"
    )
    
    # Zapisz w session state
    st.session_state.mapper_model = mapper_model
    st.session_state.etap1_model = etap1_model
    st.session_state.etap2_model = etap2_model
    st.session_state.use_async = use_async
    
    st.markdown("---")
    
    st.markdown("### ‚ÑπÔ∏è O systemie")
    
    st.markdown("""
    **System Trzyetapowy v3.0**
    
    ÔøΩ **ETAP 0: Mapowanie danych**
    - AI ekstraktuje dane z inputu
    - Strukturyzacja do modelu
    - Walidacja kompletno≈õci
    
    ÔøΩüîç **ETAP 1: Walidacja WYMOG√ìW**
    - Sprawdza tylko podane parametry
    - Precyzyjna kwalifikacja
    - Jasne uzasadnienia
    
    üèÖ **ETAP 2: Ranking JAKO≈öCI**
    - Punktacja tylko dla podanych cech
    - Scoring 0-100
    - TOP 4 rekomendacje
    
    üìä **Baza wiedzy:**
    - 11 bank√≥w
    - 87 parametr√≥w/bank
    - Inteligentne dopasowanie
    """)
    
    st.markdown("---")
    
    # Poka≈º zmapowany profil je≈õli istnieje
    if st.session_state.customer_profile:
        st.markdown("### ÔøΩ Zmapowany profil")
        
        profile = st.session_state.customer_profile
        
        # Status kompletno≈õci
        if profile.is_complete():
            st.success("‚úÖ Profil kompletny")
        else:
            missing = profile.get_missing_required_fields()
            st.warning(f"‚ö†Ô∏è Brak: {len(missing)} p√≥l")
        
        # Podstawowe info
        if profile.borrower.age:
            st.caption(f"üë§ Wiek: {profile.borrower.age} lat")
        if profile.borrower.income_type:
            st.caption(f"üíº Doch√≥d: {profile.borrower.income_type.value}")
        if profile.loan.loan_purpose:
            st.caption(f"üéØ Cel: {profile.loan.loan_purpose.value}")
        if profile.loan.loan_amount:
            st.caption(f"üí∞ Kwota: {profile.loan.loan_amount:,.0f} PLN")
        
        # Przycisk do pe≈Çnego widoku
        with st.expander("üîç Pe≈Çny JSON"):
            st.json(profile.to_dict())
    
    st.markdown("---")
    
    if st.session_state.validation_result:
        st.markdown("### üìà Statystyki analizy")
        
        summary = st.session_state.validation_result.get("validation_summary", {})
        
        col1, col2 = st.columns(2)
        with col1:
            st.metric("Zakwalifikowane", summary.get("qualified_count", 0))
        with col2:
            st.metric("Odrzucone", summary.get("disqualified_count", 0))
    
    st.markdown("---")
    
    # Download pe≈Çnego raportu
    if st.session_state.ranking_result:
        st.download_button(
            label="üì• Pobierz pe≈Çny raport",
            data=st.session_state.ranking_result,
            file_name="raport_kredytowy.md",
            mime="text/markdown",
            use_container_width=True
        )